name: Orchestrate Tasks

on:
  issues:
    types: [opened, edited]

permissions:
  issues: write
  contents: read

concurrency:
  group: orchestration-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.ORCH_TOKEN }} # Fine-grained PAT stored in tcm-orchestration
      ORCH_REPO: ${{ github.repository }}
      ORCH_ISSUE_NUMBER: ${{ github.event.issue.number }}

    steps:
      - name: Validate ORCH_TOKEN exists
        run: |
          set -euo pipefail
          if [ -z "${GH_TOKEN:-}" ]; then
            echo "Missing ORCH_TOKEN secret"
            exit 1
          fi

      - name: Install PyYAML
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Parse issue YAML and dispatch bootstrap workflows
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
        run: |
          set -euo pipefail

          python <<'PY'
          import os, re, json, subprocess, textwrap
          import yaml

          def sh(cmd: list[str]) -> str:
              try:
                res = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                return res.stdout.strip()
              except subprocess.CalledProcessError as e:
                print("COMMAND FAILED:", " ".join(cmd))
                print("STDOUT:", e.stdout)
                print("STDERR:", e.stderr)
                raise

          issue_body = os.environ.get("ISSUE_BODY") or ""
          orch_repo = os.environ["ORCH_REPO"]
          orch_issue_number = os.environ["ORCH_ISSUE_NUMBER"]
          issue_url = os.environ.get("ISSUE_URL","")

          # 1) Extract first fenced YAML block
          m = re.search(r"```ya?ml\s*(.*?)```", issue_body, re.DOTALL | re.IGNORECASE)
          if not m:
            print("No fenced ```yaml block found in issue body. Nothing to do.")
            raise SystemExit(0)

          raw_yaml = m.group(1).strip()
          try:
            data = yaml.safe_load(raw_yaml) or {}
          except Exception as e:
            print("Failed to parse YAML block:", e)
            raise SystemExit(1)

          tasks = data.get("tasks") or []
          if not isinstance(tasks, list) or not tasks:
            print("No tasks found under `tasks:`. Nothing to do.")
            raise SystemExit(0)

          # 2) Find already-dispatched task ids from issue comments
          comments_json = sh(["gh", "api", f"/repos/{orch_repo}/issues/{orch_issue_number}/comments", "--paginate"])
          comments = json.loads(comments_json) if comments_json else []
          dispatched = set()
          for c in comments:
            body = c.get("body") or ""
            for mm in re.finditer(r"TCM-DISPATCHED:\s*([A-Za-z0-9._:-]+)", body):
              dispatched.add(mm.group(1))

          # 3) Dispatch bootstrap-pr.yml for tasks with no depends_on and not already dispatched
          to_comment = []
          for t in tasks:
            if not isinstance(t, dict):
              continue

            task_id = str(t.get("id") or "").strip()
            repo = str(t.get("repo") or "").strip()  # e.g. tooleyantoine/tcm-scraper
            branch = str(t.get("branch") or "").strip()
            title = str(t.get("title") or "").strip()

            # defaults
            base_branch = str(t.get("base_branch") or "main").strip()
            claude_mode = str(((t.get("claude") or {}).get("mode")) or "manual").strip()

            claude_comment = f"@claude Task {task_id}: {title}\n\nRef: {orch_repo}#{orch_issue_number}"

            depends_on = t.get("depends_on") or []
            if depends_on and len(depends_on) > 0:
              # Phase 1: skip dependent tasks
              continue

            if not task_id or not repo or not branch or not title:
              # Minimal: require these fields
              continue

            if task_id in dispatched:
              continue

            # Determine target repo default branch (so we can dispatch against it reliably)
            repo_info = sh(["gh", "api", f"/repos/{repo}"])
            default_branch = json.loads(repo_info).get("default_branch") or "main"

            # Find workflow id by path (more reliable than calling by filename directly)
            wfs_json = sh(["gh", "api", f"/repos/{repo}/actions/workflows"])
            wfs = json.loads(wfs_json).get("workflows", [])
            wf = next((w for w in wfs if (w.get("path") or "").endswith("/bootstrap-pr.yml")), None)
            if not wf:
              raise SystemExit(f"Could not find workflow bootstrap-pr.yml in {repo}. Is it on the default branch and in .github/workflows/?")

            workflow_id = wf["id"]

            sh([
              "gh", "api",
              "-X", "POST",
              f"/repos/{repo}/actions/workflows/{workflow_id}/dispatches",
              "-H", "Accept: application/vnd.github+json",
              "-f", f"ref={default_branch}",
              "-f", "inputs[branch]="+branch,
              "-f", "inputs[base_branch]="+base_branch,
              "-f", "inputs[title]="+title,
              "-f", "inputs[task_id]="+task_id,
              "-f", f"inputs[issue_repo]={orch_repo}",
              "-f", f"inputs[issue_number]={orch_issue_number}",
              "-f", "inputs[claude_mode]="+claude_mode,
              "-f", f"inputs[claude_comment]={claude_comment}",
            ])

            to_comment.append(f"- TCM-DISPATCHED: {task_id} → {repo} ({branch})")

          if not to_comment:
            print("No eligible tasks to dispatch (either none, all dependent, or already dispatched).")
            raise SystemExit(0)

          comment_body = "✅ Dispatched bootstrap workflows:\\n\\n" + "\\n".join(to_comment) + "\\n"
          if issue_url:
            comment_body += f"\\nOrchestration issue: {issue_url}\\n"

          sh([
            "gh", "api",
            "-X", "POST",
            f"/repos/{orch_repo}/issues/{orch_issue_number}/comments",
            "-f", "body="+comment_body
          ])

          print("Done. Comment posted with dispatched tasks.")
          PY
